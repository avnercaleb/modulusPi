/******************************************************************************/
/* Files to Include                                                           */
/******************************************************************************/

#include "user_RF.h"


/******************************************************************************/
/* Variable Declaration                                                       */
/******************************************************************************/

volatile SYS_STRUCT sys;        /* System struct - configurations, flags, adc values */
SYS_STRUCT *sysPt;

volatile PWR_CONSUME_STRUCT pwr;
PWR_CONSUME_STRUCT *pwrPt;

extern volatile RF_STRUCT rf;
extern RF_STRUCT *rfPt;

volatile MSGBUFF_STRUCT msgBuff;     /* Struct to create a buffer of the last 3 msgs received */
MSGBUFF_STRUCT *msgBuffPt;


struct timeval tiMsg, tfMsg;	/* Structures to count 2s to compare RF messages */
uint16_t timerMsg;

/* AES 128bit Encryption consts & variables */
uint8_t auxLen;

/* New key generated by a java script */
extern const uint8_t AESKey128[];

/* Variable to receive the session key */
AES_SESSION_KEY_128_BIT session_key;

uint8_t encrypt[BLOCK_SIZE_3]={0};
uint8_t decrypt[BLOCK_SIZE_3]={0};
uint8_t auxBuff[BLOCK_SIZE_3]={0};

uint8_t buffMsg[BLOCK_SIZE_3];          /* It is necessary to create a continuous buffer before encryption */


const uint8_t versionMsg[]="\r\n\n ONE_RPI_API_V1.0 - 22/11/2016 \n By Andre Gomes \r\n";

//MODBUS Global Variables
unsigned int mainsVoltage;
unsigned int loadCurrent;
unsigned long int test;

int uart0_filestream;
struct termios options;
unsigned char tx_buffer[TX_BUFFER];
unsigned char rx_buffer[RX_BUFFER];
int rx_length;
unsigned char rxEnd = 0;
unsigned int rxIndex = 0;
unsigned int temp;
unsigned int crcRx;
int count;
unsigned char initMeasure = 0;

float v1,v2,v3;
float i1,i2,i3;
float p1,p2,p3;
float kwhSum;
float mwhSum;
float auxfp1,auxfp2,auxfp3;
short int fp1,fp2,fp3;

float v1Sum,v2Sum,v3Sum;
float i1Sum,i2Sum,i3Sum;
float p1Sum,p2Sum,p3Sum;
float primTP,secTP,primTC,secTC;
float sample;
float RTP,RTC;


int crcBypass = 0;  //used to jump crc check on TCP connections
int connection=-1;
int resetConnection=0;
int connectionRetry=0;


#ifdef UDP //UDP CLIENT VARIABLE

unsigned int clientSocket, nBytes;
unsigned int portNum = 1001; //port device
char serverIP[] = "10.1.25.100"; //ip device
struct sockaddr_in serverAddr;
int bytesAv=0;
socklen_t addr_size;

#endif

#ifdef TCP //TCP CLIENT VARIABLE

unsigned int clientSocket, nBytes;
unsigned int portNum=1001; //port device defull tcp/ip connections
//char serverIP[]="192.168.0.80"; //IP DEVIDE FRONIUS ECOLUZ
char serverIP[]="10.1.25.100";
struct sockaddr_in serverAddr;
int bytesAv=0;
socklen_t addr_size;

#endif


char testMsg[8];

#ifdef JANITZA

	char modbusQuery[] = {0x01,0x03,0x4A,0x38,0x00,0x46,0x53,0xED};
	
#endif

#ifdef 3R

	char modbusQuery[] = {0x0A,0x04,0x00,0x00,0x00,0x0D,0x30,0xB4};
	
#endif
  
#ifdef CCK

	#ifdef RS485
	char modbusGetRT[] = {0x01,0x03,0x04,0x78,0x00,0x08,0xC5,0x25};
	char modbusQuery[] = {0x01,0x03,0x04,0x02,0x00,0x4E,0x65,0x0E};
	//char modbusQuery[] = {0x01,0x03,0x04,0x02,0x00,0x02,0x64,0xFB};
	#endif
	
	#ifdef TCP
	char modbusQuery[] = {0x00,0x00,0x00,0x00,0x00,0x06,0x01,0x03,
						0x04,0x02,0x00,0x80};
	//char modbusQuery[] = {0x01,0x03,0x04,0x02,0x00,0x02,0x64,0xFB};
	#endif
		
#endif


#ifdef FRONIUS
	char modbusGetRT[]= {0x00};

	char modbusQuery[] = {0x00,0x00,0x00,0x00,0x00,0x06,0x01,0x03,0x9C,0x89,0x00,0x2E}; 


#endif


#ifdef EMBRASUL_MD30_ETH


	//char modbusGetRT[] = {0x01,0x03,0x00,0x3e,0x00,0x04,0x25,0xc5};
	//char modbusQuery[] = {0x01,0x03,0x00,0x44,0x00,0x48,0x05,0xe9};
	
	char modbusGetRT[] = {0x00,0x00,0x00,0x00,0x00,0x06,0x01,0x03,0x00,0x3e,0x00,0x04};
	char modbusQuery[] = {0x00,0x00,0x00,0x00,0x00,0x06,0x01,0x03,0x00,0x44,0x00,0x48};
	

#endif
	

/* Aux variables */
uint16_t msgID_len;


/******************************************************************************/
/* User Functions                                                             */
/******************************************************************************/

/**
 * Function to config the IO Ports and the Peripherals
 */
uint8_t ConfigInit()
{
    uint8_t key[16];

#if DEBUG_VERSION_MSG
    /* Show version firmware through UART */
    printf(versionMsg);
#endif


    /* Initialize system struct pointer and structure */
    sysPt = &sys;
    memset(sysPt, 0x00, sizeof(SYS_STRUCT));

    /* Initialize structure for power consumption calculation */
    pwrPt = &pwr;
    memset(pwrPt, 0x00, sizeof(PWR_CONSUME_STRUCT));


	/* Verify if the memory file is created and accessible */
    if (Memory_Open() != 0) return 1;
    Memory_Close();

	/* Initiliaze rf structs and pointers*/
    rfPt = &rf;
    memset(rfPt, 0x00, sizeof(RF_STRUCT));

    /* Get the data saved in memory file */
    if (Memory_GetSavedData(sysPt, rfPt) != 0) return 1;

    /* Initialize SPI and RF module */
    #ifdef RF_RFM22B
		if (RF_RFM22B_Setup(rfPt) < 0) return 1;
	#endif
	
	#ifdef RF_RFM69HCW
		if (RF_RFM69HCW_Setup(rfPt) < 0) return 1;		
	#endif
	
	#ifdef RF_RFM95W
		if (RF_RFM95W_Setup(rfPt) < 0) return 1;		
	#endif	
	
    /* Initialize the Buffer for the last 3 msgs */
    msgBuffPt = &msgBuff;
    memset(msgBuffPt, 0x00, sizeof(MSGBUFF_STRUCT));
    msgBuff.ordIDact = 0x01;

    /* Initialize AES128 Encryption - Session Key calculation */
    memcpy(key, AESKey128, AES_BLOCK_SIZE);
    AESCreateSessionKey(key, &session_key, AES_KEY_TYPE_128_BIT);  
    
    return 0;
}



/******************************************************************************/
/* RF Functions                                                               */
/******************************************************************************/

/**
 * Function to Initialize the RF Module
 */
 
 #ifdef RF_RFM22B
 int8_t RF_RFM22B_Setup(volatile RF_STRUCT *rfData)
 {
	int8_t init;

	/* Setup wiringPi library */
	wiringPiSetup();

	/* Config the SPI peripheral of the Raspberry Pi */
	if ((init = wiringPiSPISetup(SPI_PORT, SPI_SPEED)) < 0)
		return init;

	/* Initialize rf module */
	RF_RFM22B_Config(rfData);

	/* Set the RF interrupt pin as input and set the pull-up to Vcc */
	pinMode(RF_INT_PIN, INPUT);
	pullUpDnControl(RF_INT_PIN, PUD_UP);

	/* Set the interrupt for the state-machine control */
	wiringPiISR (RF_INT_PIN, INT_EDGE_FALLING, &RF_Interrupt);

	return init;
}
#endif

#ifdef RF_RFM69HCW
int8_t RF_RFM69HCW_Setup(volatile RF_STRUCT *rfData)
{
	int8_t init;

	/* Setup wiringPi library */
	wiringPiSetup();	

	/* Config the SPI peripheral of the Raspberry Pi */
	if ((init = wiringPiSPISetup(SPI_PORT, SPI_SPEED)) < 0) return init;

	/* Initialize rf module */
	RF_RFM69HCW_Config();
	
	/* Set the RF interrupt pin as input and set the pull-up to Vcc */
	pinMode(RF_INT_PIN, INPUT);
	pullUpDnControl(RF_INT_PIN, PUD_DOWN);

	/* Set the interrupt for the state-machine control */
	wiringPiISR (RF_INT_PIN, INT_EDGE_RISING, &RF_Interrupt);

	return init;
}
#endif

#ifdef RF_RFM95W
int8_t RF_RFM95W_Setup(volatile RF_STRUCT *rfData)
{
	int8_t init;
	
	/* Setup wiringPi library */
	wiringPiSetup();	

	/* Config the SPI peripheral of the Raspberry Pi */
	if ((init = wiringPiSPISetup(SPI_PORT, SPI_SPEED)) < 0) return init;

	/* Initialize rf module */
	RF_RFM95W_Config();
	
	/* Set the RF interrupt pin as input and set the pull-up to Vcc */
	pinMode(RF_INT_PIN, INPUT);
	pullUpDnControl(RF_INT_PIN, PUD_DOWN);

	/* Set the interrupt for the state-machine control */
	wiringPiISR (RF_INT_PIN, INT_EDGE_RISING, &RF_Interrupt);
	
	return init;
}
#endif



/**
 * Function to process the received RF message
 * @param 1 - RF_STRUCT pointer
 * @param 2 - MSGBUFF_STRUCT pointer
 * @param 3 - SYS_STRUCT pointer
 */
void RF_ProcessMsg(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData)
{
    uint8_t *buffPt;
    RFMSG_STRUCT *msgPt, *msgPtAux;                // Pointer for the message struct
    uint8_t crcCmp, ckSum, msgCmp=0;
    #if DEBUG_RF_RX_MSGPRINT
        uint8_t i;
    #endif


	/* Check the time interval between msgs received */
	gettimeofday(&tfMsg, NULL);

	timerMsg = (uint16_t)(tfMsg.tv_sec - tiMsg.tv_sec);

	/* Update the timer */
	gettimeofday(&tiMsg, NULL);

	if (timerMsg < RF_CNT_MSGS)
	{
		rfData->cnt5s = 1;
	}
	else
	{
		rfData->cnt5s = 0;

        /* Clear msg buffer */
        memset(msgBuffPt, 0x00, DATA_SIZE_CLEAR);
	}


    /* Initialize uint8_t pointer for the RF message structure */
    buffPt = &rfData->rxMsg;

    /* Initialize RFMSG_STRUCT pointer for the RF message structure */
    msgPt = &rfData->rxMsg;


    /* Get the bytes received using the pointer for the RF Struct*/
    if (sysData->encCtrl == ENC_ON)
    {
		#ifdef RF_RFM22B
            crcCmp = RF_RFM22B_ReadRXfifo(buffMsg, &rfData->rxMsg.len);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_ReadRXfifo(buffMsg, &rfData->rxMsg.len);
        #endif
        #ifdef RF_RFM95W
            RF_RFM95W_ReadRXfifo(buffMsg, &rfData->rxMsg.len);
        #endif
	}
    else
	{
		#ifdef RF_RFM22B
            crcCmp = RF_RFM22B_ReadRXfifo(buffPt, &rfData->rxMsg.len);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_ReadRXfifo(buffPt, &rfData->rxMsg.len);
        #endif
        #ifdef RF_RFM95W
            RF_RFM95W_ReadRXfifo(buffPt, &rfData->rxMsg.len);
        #endif
	}


    /* If the message has bad CRC exit the function */
#ifdef RF_RFM22B
    if (crcCmp == 1)
    {
#endif 
#ifdef RF_RFM95W
    if ((RF_RFM95W_ReadReg(RF_REG_IRQ_FLAGS) & 0x50) == 0x50) // Verifies RX done and Valid Header and no CRC error
    {
#endif 
        /* Check if the system is in encryption mode */
        if (sysData->encCtrl == ENC_ON)
        {
            if ((rfData->rxMsg.len >= BLOCK_SIZE_1) && (rfData->rxMsg.len <= BLOCK_SIZE_3))
            {
                /* Decrypt the message to be sent and get the length of the decrypted message */
                rfData->rxMsg.len = AES128_Decrypt(buffMsg, rfData->rxMsg.len, decrypt, &session_key);
            }
        }
        
        if ((rfData->rxMsg.len >= MIN_RFMSG_LEN) && (rfData->rxMsg.len <= MAX_RFMSG_LEN))
        {

            if (sysData->encCtrl == ENC_ON)
            {
                #if DEBUG_RF_RX_MSGPRINT
                    printf("\n\nRX Buff Decrypted: ");
                    for (i=0; i<rfData->rxMsg.len; i++)
                    {
                        printf("%02X ", *(decrypt+i));
                    }
                    printf("\n\n");
                #endif

                memcpy(buffPt, decrypt, rfData->rxMsg.len);
            }

            /* Fill the RF_Structure with the right values */
            rfData->rxMsg.ttl = rfData->rxMsg.data[rfData->rxMsg.len-HEADER-2];
            rfData->rxMsg.data[rfData->rxMsg.len-HEADER-2] = 0x00;

            rfData->rxMsg.cks = rfData->rxMsg.data[rfData->rxMsg.len-HEADER-1];
            rfData->rxMsg.data[rfData->rxMsg.len-HEADER-1] = 0x00;


            #if DEBUG_RF_RX_MSGPRINT
            	printf("\n\nRX Buff: ");
                for (i=0; i<rfData->rxMsg.len-2; i++)
                {
                    printf("%02X ", *(buffPt+i));
                }
                printf("%02X %02X ", rfData->rxMsg.ttl, rfData->rxMsg.cks);
                printf("\n\n");
            #endif


            /* Calculate the checksum of the msg received */
            ckSum = RF_CksCalc(msgPt);

            /* Check if the message is OK */
            if (ckSum == rfData->rxMsg.cks)
            {

                // Test if the message is equal to one of the last 3 messages
                if ((msgBuffData->ordID[0] == rfData->rxMsg.ordID) && (msgBuffData->msgID[0] == rfData->rxMsg.msgID) && (msgBuffData->net[0] == rfData->rxMsg.net))
                {
                    msgCmp = 0;
                }
                else if ((msgBuffData->ordID[1] == rfData->rxMsg.ordID) && (msgBuffData->msgID[1] == rfData->rxMsg.msgID) && (msgBuffData->net[1] == rfData->rxMsg.net))
                {
                    msgCmp = 0;
                }
                else if ((msgBuffData->ordID[2] == rfData->rxMsg.ordID) && (msgBuffData->msgID[2] == rfData->rxMsg.msgID) && (msgBuffData->net[2] == rfData->rxMsg.net))
                {
                    msgCmp = 0;
                }
                else
                {
                    /* The msg is different from last 3 msgs*/
                    msgCmp = 1;
                }

                /* To check if the message belongs to this RF protocol check the size of the message
                 * To maintain one single comparison we will put together the msgID and the length of the message
                 * then we compare the value */
                msgID_len = (rfData->rxMsg.msgID << 8) | rfData->rxMsg.len;


                #if DEBUG_RF_RX_MSGHANDLER
                    printf("\nMsgCmp: %d | Cnt5s: %d | OrdIDAct: %d\n", msgCmp, rfData->cnt5s, msgBuff.ordIDact);
                #endif


                //Checks if the 5s interval between msgs has passed in case of receiving the same msg
                if (((msgCmp == 0) && (rfData->cnt5s == 0)) || (msgCmp > 0))
                {
                    /* Save the parameters of last valid message */
                    msgBuffData->ordID[msgBuffData->ind] = rfData->rxMsg.ordID;
                    msgBuffData->msgID[msgBuffData->ind] = rfData->rxMsg.msgID;
                    msgBuffData->net[msgBuffData->ind] = rfData->rxMsg.net;

                    /* Update the index of the circular buffer */
                    msgBuffData->ind++;
                    if (msgBuffData->ind > 2)
                        msgBuffData->ind = 0;

                    /* The current Order ID should be saved, for the ans/ack msgs */
                    msgBuffData->ordIDact = rfData->rxMsg.ordID;

                    /* Check if is a debug/technical message */
                    if (rfData->rxMsg.ordID == DEBUG_ORD_ID)
                    {
                        if (msgID_len == ASK_WHOIS)
                        {
                            rfData->msgIDsend = ANS_WHOIS;
                        }
                    }
                    /* Network config message - Don't have the length of the message, it's compared separately */
                    else if ((rfData->rxMsg.msgID == CONF_NET) && (rfData->rxMsg.sn == sysData->sn) && (rfData->rxMsg.len == CONF_NET_LEN))
                    {
                        sysData->net = rfData->rxMsg.net;

                        /* Save to EEPROM the new network number */
                        Memory_WritePos(NET_POS, &sysData->net);

                        /* Send ACK */
                        rfData->msgIDsend = ACK_CONF_NET;

                    } //END if ((rfData->rxMsg.msgID == CONF_NET) && (rfData->rxMsg.sn == sysData->sn))
                    else if ((rfData->rxMsg.net == sysData->net) && ((rfData->rxMsg.sn == sysData->sn) || (rfData->rxMsg.sn == BROADCAST)))	//Check if the message is for this device
                    {
                        switch(msgID_len)
                        {

                            //GENRERAL CONFIGS MESSAGE - Broadcast/Unicast
                            case CONF_GENERAL:

								/* Copy configurations to SYS_STRUCT */

                            	/* Get the TTL config and save it */
                            	sysData->ttlMAX = rfData->rxMsg.data[5];
                            	Memory_WritePos(TTLMAX_POS, &sysData->ttlMAX);

                                /* If it is Unicast msg send ACK*/
                                if (rfData->rxMsg.sn != BROADCAST)
                                    rfData->msgIDsend = ACK_CONF_GENERAL;

                                break;

                            //ASK TELEMETRY MESSAGE - Unicast
                            case ASK_TELEM_EXT:
                                
                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    /* Reply to the request */
                                    rfData->msgIDsend = ANS_TELEM_EXT;
                                }

                                break;

                            //ADDITIONAL CONFIGURATIONS MESSAGE - Broadcast/Unicast
                            case CONF_ADDON:

                                /* Set the new configurations */

                                
                                /* If it is Unicast msg send ACK*/
                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    rfData->msgIDsend = ACK_CONF_ADDON;
                                }

                                /* The flag indicates the Update ID - Save the new configurations in EEPROM */
                                //sysData->updateID = ADDON_CONFIGS_UPDATE;

                                break;

                            case SYS_TOTALTEL:

                                if (rfData->rxMsg.sn != BROADCAST)
                                {
                                    /* Reply to the request */
                                    rfData->msgIDsend = ANS_SYS_TOTALTEL;
                                }

                                break;

                            default:
                                #if DEBUG_WRONG_MSG
                                    printf("\nWrong ID/Length!\n");
                                #endif

                                break;
                        }


                        //If is a broadcast message - re-sends the message
                        if ((rfData->rxMsg.sn == BROADCAST) && (rfData->rxMsg.ttl < sys.ttlMAX))
                        {
                            #if DEBUG_RESEND_RF
                            printf("\nRe-Send Broadcast message!\n");
                            #endif

                            /* fill the tx buffer to re-send the message */
                            msgPtAux = &rfData->txMsg;
                            memcpy(msgPtAux, msgPt, rfData->rxMsg.len-2);     /* Copy the header and data */

                            /* For each forwarding increase TTL */
                            rfData->txMsg.ttl = rfData->rxMsg.ttl + 1;

                            rfData->txMsg.len = rfData->rxMsg.len;

                            //Re-send message
                            rfData->msgIDsend = RE_SEND;
                        }

                    } //END if ((rfData->rxMsg.net == sysData->net) && ((rfData->rxMsg.sn == sysData->sn) || (rfData->rxMsg == BROADCAST)))
                    else if (rfData->rxMsg.ttl < sys.ttlMAX)
                    {
                        //If msg hasn�t the same serial or network re-sends to the others

                        /* fill the tx buffer to re-send the message */
                        msgPtAux = &rfData->txMsg;
                        memcpy(msgPtAux, msgPt, rfData->rxMsg.len-2);     /* Copy the header and data */

                        /* For each forwarding increase TTL */
                        rfData->txMsg.ttl = rfData->rxMsg.ttl + 1;

                        rfData->txMsg.len = rfData->rxMsg.len;

                        //Re-send message
                        rfData->msgIDsend = RE_SEND;
                    }

                    #if DEBUG_RCV_RF
                    printf("\nMsg received\n");
                    #endif

                    //Start 5s counter
                    rfData->cnt5s = 1;

                } //END if (((msgCmp == 0) && (rfData->cnt5s == 0)) || (msgCmp != 0))
                #if DEBUG_RF_5S
                else
                {
                    printf("\nMsg, t < 5s\n");
                }
                #endif

            } //END if ( (crcCmp == 1) && (ckSum == rfData->rxMsg.cks) )
            #if DEBUG_RF_ERROR
            else
            {
                printf("\nERROR receiving RF msg!\n");
            }
            #endif


        } // END if ((rfData->rxMsg.len > MIN_RFMSG_LEN) && (rfData->rxMsg.len <= MAX_RFMSG_LEN))
        
#ifdef RF_RFM22B
    } // END if (crcCmp == 1)
#endif
#ifdef RF_RFM95W 
    }
#endif  
    

    /* Clear RX Buffer to avoid errors in the next received message*/
    RF_ClrMsg(msgPt);
  
    /* Clear encryption buffer */
    SYS_ClearBuff(decrypt, MAX_RFMSG_LEN);
    SYS_ClearBuff(buffMsg, MAX_RFMSG_LEN);
    
}


/**
 * Function to send a RF message
 * @param 1 - RF_STRUCT pointer
 * @param 2 - MSGBUFF_STRUCT pointer
 * @param 3 - SYS_STRUCT pointer
 */
void RF_SendMsg(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData)
{
    RFMSG_STRUCT *txMsgPt;
    uint8_t *buffPt;
    uint8_t rndDly=0, dly=0;
    uint8_t newLen;
#if DEBUG_SEND_RF_MSG
    uint8_t i;
#endif

    /* Change RF-State to Ready Mode/Standby Mode - disable reception of new messages */
	#ifdef RF_RFM22B
        RF_RFM22B_ReadyMode();    
    #endif
    #ifdef RF_RFM69HCW
        RF_RFM69HCW_StandbyMode();
    #endif
    #ifdef RF_RFM95W
        RF_RFM95W_StandbyMode();
    #endif  
    
    /* Initialize pointer for message */
    txMsgPt = &rfData->txMsg;

    /* Set Order ID and Msg ID */
    rfData->txMsg.ordID = msgBuffData->ordIDact;

    
    if (rfData->msgIDsend == RE_SEND)
    {
        //The message was copied ant the TTL set in processRf() function

        /* Set the values for the delays */
        rndDly = RE_SEND_RND_DLY;
        dly = RE_SEND_DLY;
    }
    else
    {
        // Write the network (NET+SN) header to the tx buffer
        rfData->txMsg.sn = sysData->sn;
        rfData->txMsg.net = sysData->net;

        // Set TTL byte to 1
        rfData->txMsg.ttl = 1;

        switch(rfData->msgIDsend)
        {
            case ACK_CONF_NET:

                /* Set the corresponding ID and OK byte */
                rfData->txMsg.msgID = ACK_CONF_NET;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_NET_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ACK_CONF_GENERAL:

                 /* Set the corresponding ID and OK byte */
                rfData->txMsg.msgID = ACK_CONF_GENERAL;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_GENERAL_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ANS_TELEM_EXT:

                /* Set the corresponding ID */
                rfData->txMsg.msgID = ANS_TELEM_EXT;
                
                /* Reset Process Variables to sync with OMS */
                ResetProcessVars();                
                
                /* Write telemetry information to the buffer */
                //memcpy(rfData->txMsg.data+TELEM_KWH_POS, &kwhSum, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 0, &v1, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 4, &v2, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 8, &v3, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 12, &i1, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 16, &i2, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 20, &i3, DOUBLE_SIZE);
                memcpy(rfData->txMsg.data + 24, &fp1, 2);
                memcpy(rfData->txMsg.data + 26, &fp2, 2);
                memcpy(rfData->txMsg.data + 28, &fp3, 2);
                memcpy(rfData->txMsg.data + 30, &kwhSum, DOUBLE_SIZE); 
                                              
                //memcpy(rfData->txMsg.data + 24, &p1, DOUBLE_SIZE);
                //memcpy(rfData->txMsg.data + 28, &p2, DOUBLE_SIZE);
                //memcpy(rfData->txMsg.data + 32, &p3, DOUBLE_SIZE);               
                //memcpy(rfData->txMsg.data + 36, &kwhSum, DOUBLE_SIZE);

                /* Set length of the RF message */
                //rfData->txMsg.len = ANS_TELEM_EXT_LEN;
                //rfData->txMsg.len = ANS_TELEM_ENERGY_LEN;
                rfData->txMsg.len = ANS_TELEM_ENERGY_LEN_2;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ACK_CONF_ADDON:

                 /* Set the corresponding ID */
                rfData->txMsg.msgID = ACK_CONF_ADDON;
                rfData->txMsg.data[0] = OK_MSG;

                /* Set length of the RF message */
                rfData->txMsg.len = ACK_CONF_ADDON_LEN;

                /* Set the values for the delays */
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ANS_SYS_TOTALTEL:

                //Set the corresponding ID
                rfData->txMsg.msgID = ANS_SYS_TOTALTEL;

                // Write the totalisers data to the buffer
                //buffPt = &pwrData->kw;                                   /* Write kW and kVAr */
                //memcpy(rfData->txMsg.data, buffPt, TOTALIZERS_DATA_LEN);

                rfData->txMsg.len = ANS_SYS_TOTALTEL_LEN;

                // Set the values for the delays
                rndDly = ACK_ANS_RND_DLY;
                dly = ACK_ANS_DLY;

                break;

            case ALARM_MSG:

                /* Re-Set Order ID */
                rfData->txMsg.ordID = 0x01;

                /* Set the corresponding ID */
                rfData->txMsg.msgID = ALARM_MSG;

                /* Write alarm information to the buffer */
                /*rfData->txMsg.data[ALR_LAMP] = (alrData->resume >> LAMP_POS) & 0x01;
                rfData->txMsg.data[ALR_TEMPLAMP] = (alrData->resume >> TEMPLAMP_POS) & 0x01;
                rfData->txMsg.data[ALR_TEMPPCB] = (alrData->resume >> TEMPPCB_POS) & 0x01;
                rfData->txMsg.data[ALR_STAB] = (alrData->resume >> STAB_POS) & 0x01;
                rfData->txMsg.data[ALR_CURR] = (alrData->resume >> CURR_POS) & 0x01;
                rfData->txMsg.data[ALR_VOLT] = (alrData->resume >> VOLT_POS) & 0x01;
                rfData->txMsg.data[ALR_LDR] = (alrData->resume >> LDR_POS) & 0x01;*/

                /* Set length of the RF message */
                rfData->txMsg.len = ALARM_MSG_LEN;

                break;

            case ANS_WHOIS:

                /* Set the respective Order ID for the answer to DEBUG messages */
                rfData->txMsg.ordID = DEBUG_ORD_ID;

                /* Set the corresponding ID */
                rfData->txMsg.msgID = ANS_WHOIS;

                //Send the value off the RSSI (msg received)
                rfData->txMsg.data[0] = rfData->rssiVal;

                /* Set length of the RF message */
                rfData->txMsg.len = ANS_WHOIS_LEN;

                rndDly = DEBUG_RND_DLY;
                dly = DEBUG_DLY;

                break;
                
            default:
                break;

        } // END switch(rfData->msgIDsend)

    }

    /* Calculation of the checksum */
    rfData->txMsg.cks = RF_CksCalc(txMsgPt);


    /*********************/
    /*    Send RF msg    */
    /*********************/
    if (rfData->msgIDsend != ALARM_MSG)
    {
        delay((rand() % rndDly) + dly);
    }

    #if DEBUG_SEND_RF_MSG
        buffPt = txMsgPt;
        printf("\n\nTX Buff: ");
        for (i=0; i<rfData->txMsg.len-2; i++)
        {
            printf("%02X ", *(buffPt+i));
        }
        printf("%02X %02X ", rfData->txMsg.ttl, rfData->txMsg.cks);
        printf("\n\n");
    #endif

    /* Create a continuous buffer for the message to be sent - Header+Data+TTL+CKS */
    buffPt = txMsgPt;
    memcpy(buffMsg, buffPt, txMsgPt->len-2);     /* Copy the header and data */

    buffMsg[txMsgPt->len-2] = txMsgPt->ttl;         /* Copy the ttl */
    buffMsg[txMsgPt->len-1] = txMsgPt->cks;         /* Copy the cks */
   
   
    if (sysData->encCtrl == ENC_ON)
    {            
        /* Encrypt the message to be sent */
        newLen = AES128_Encrypt(buffMsg, txMsgPt->len, encrypt, &session_key);
        
        /* Write message to RF FIFO and start transmission */
        /* Write message to RF FIFO and start transmission */
        #ifdef RF_RFM22B
            RF_RFM22B_WrtTXfifo(encrypt, newLen);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_WrtTXfifo(encrypt, newLen);
        #endif
        #ifdef RF_RFM95W
            RF_RFM95W_WrtTXfifo(encrypt, newLen);
        #endif
    }
    else
    {
        /* Write message to RF FIFO and start transmission */ 
		#ifdef RF_RFM22B
            RF_RFM22B_WrtTXfifo(buffMsg, txMsgPt->len);
        #endif
        #ifdef RF_RFM69HCW
            RF_RFM69HCW_WrtTXfifo(buffMsg, txMsgPt->len);   
        #endif
        #ifdef RF_RFM95W
            RF_RFM95W_WrtTXfifo(buffMsg, txMsgPt->len);   
        #endif  
    }    

    rfData->msgSent = 1;                        /* set message sent change of the RF-state */

    /* wait cycle */
    #ifdef RF_RFM22B
        delay(10);
    #endif
    #ifdef RF_RFM69HCW
        delay(5);    
    #endif
    #ifdef RF_RFM95W
        delay(5);    
    #endif

    //----------------------------------------//

    if (rfData->msgIDsend != RE_SEND)
    {
        /* Save the parameters of the last valid message - The message is only sent once
         If is RE_SEND order, the parameters was already saved */
        msgBuffData->ordID[msgBuffData->ind] = rfData->txMsg.ordID;
        msgBuffData->msgID[msgBuffData->ind] = rfData->txMsg.msgID;
        msgBuffData->net[msgBuffData->ind] = rfData->txMsg.net;

        /* Update the index of the circular buffer */
        msgBuffData->ind++;

        if (msgBuffData->ind > 2)
            msgBuffData->ind = 0;
    }

    /* Clear RX Buffer to avoid errors in the next received message */
    RF_ClrMsg(txMsgPt);
  
    /* Clear encryption buffer */
    SYS_ClearBuff(encrypt, sizeof(encrypt));
    
    /* Start 5s counter */
    rfData->cnt5s = 1;

}


/**
 * Function to be called when a interrupt occurs on the pin 5 - RF Interrupt
 */
void RF_Interrupt(void)
{
	/* Set the flag of the interrupt */
	rf.int_RF = 1;
}


/**
 * Function to implement the State-Machine for the RF communication
 * @param 1 - RF_STRUCT pointer
 * @param 2 - MSGBUFF_STRUCT pointer
 * @param 3 - SYS_STRUCT pointer
 */
#ifdef RF_RFM22B
void RF_RFM22B_SttMachine(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData)
{
    /* Disable rf interrupts to avoid more interrupts */
    RF_RFM22B_DisRfInt();
    RF_RFM22B_ClrRfInt();

    /* Check if a message has been sent*/
    if (rfData->msgSent == 1)
    {
        RF_RFM22B_RxMode();         /* Switch to RX Mode */
        rfData->msgSent = 0;
    }
    else
    {
        /* The interruption was caused by a reception of a new msg */        
        rfData->msgRcv = 1;     /* Flag for the control of RF Crash */

        /* Disable the reception of messages */
        RF_RFM22B_ReadyMode();

        /* Handling of the message received */
        RF_ProcessMsg(rfData, msgBuffData, sysData);
        RF_RFM22B_RxMode();          /* Switch back to RX Mode */
    }

    /* Enable RF interrupts */
    RF_RFM22B_EnRfInt();
}
#endif

#ifdef RF_RFM69HCW
void RF_RFM69HCW_SttMachine(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData)
{   
    #ifdef DEBUG_RF_STTMCH
        printf("\n RF Int detected! \n");
    #endif       
        
    /* Set Standby Mode to avoid more interruptions */
    RF_RFM69HCW_StandbyMode();    
    
    /* Check if a message has been sent*/
    if (rfData->msgSent == 1)
    {
        #ifdef DEBUG_RF_STTMCH
            printf("\n RF msg sent! \n");
        #endif

        rfData->msgSent = 0;
    }
    else
    {
        #ifdef DEBUG_RF_STTMCH
            printf("\n RF msg received! \n");
        #endif
            
        /* The interruption was caused by a reception of a new msg */        
        rfData->msgRcv = 1;     /* Flag for the control of RF Crash */

        /* Handling of the message received */
        RF_ProcessMsg(rfData, msgBuffData, sysData);
    }    
    
    /* Switch back to RX Mode */
    RF_RFM69HCW_RxMode();
    
    /* Wait to enter in RX Mode */
    delay(2);    
}
#endif


#ifdef RF_RFM95W
void RF_RFM95W_SttMachine(RF_STRUCT *rfData, MSGBUFF_STRUCT *msgBuffData, SYS_STRUCT *sysData)
{   
    #ifdef DEBUG_RF_STTMCH
        printf("\n RF Int detected! \n");
    #endif       
        
    /* Set Standby Mode to avoid more interruptions */
    RF_RFM95W_StandbyMode();    
    
    /* Check if a message has been sent*/
    if (rfData->msgSent == 1)
    {
        #ifdef DEBUG_RF_STTMCH
            printf("\n RF msg sent! \n");
        #endif

        rfData->msgSent = 0;
    }
    else
    {
        #ifdef DEBUG_RF_STTMCH
            printf("\n RF msg received! \n");
        #endif
            
        /* The interruption was caused by a reception of a new msg */        
        rfData->msgRcv = 1;     /* Flag for the control of RF Crash */

        /* Handling of the message received */
        RF_ProcessMsg(rfData, msgBuffData, sysData);
    }    
    
    /* Switch back to RX Mode */
    RF_RFM95W_RxMode();
    
    /* Wait to enter in RX Mode */
    delay(2);    
}
#endif


/**
 * Function to Set a Software Reset on the RF module
 * @param 1 - RF_STRUCT pointer
 */
#ifdef RF_RFM22B
void RF_RFM22B_Reset(RF_STRUCT *rfData)
{    
#if DEBUG_RF_RESET
    printf("\nReset Sequence Started!\n");
#endif

    /* Disable interrupts and set RF Interrupt flag to zero */
    RF_RFM22B_DisRfInt();
    rfData->int_RF = 0;
        
    /* Set Software Reset and wait 1ms> */
    RF_RFM22B_SetSoftRESET();    
    delay(10);

    /* Initial RF Configurations */   
    RF_RFM22B_Config(rfData);
    
    /* Clear RF flags */
    rfData->int_RF = 0;
    rfData->msgRcv = 0;
    rfData->msgSent = 0;
    
#if DEBUG_RF_RESET
    printf("\nEnd of Reset Sequence!\n");
#endif
}
#endif

#ifdef RF_RFM69HCW
void RF_RFM69HCW_Reset(RF_STRUCT *rfData)
{
#if DEBUG_RF_RESET
    UART_PrintString("\nReset Sequence Started!\n");
#endif
    
    /* Set RF Interrupt flag to zero */
    rfData->int_RF = 0;
    
    /* Reonfigure the RF module*/
    RF_RFM69HCW_Config();
    
    /* Change RF Module to restart the receiving stage */
    RF_RFM69HCW_ChgStt();
    
    /* Clear RF flags */
    rfData->int_RF = 0;
    rfData->msgRcv = 0;
    rfData->msgSent = 0;
    
#if DEBUG_RF_RESET
    UART_PrintString("\nEnd of Reset Sequence!\n");
#endif    
}
#endif

#ifdef RF_RFM95W
void RF_RFM95W_Reset(RF_STRUCT *rfData)
{
#if DEBUG_RF_RESET
    UART_PrintString("\nReset Sequence Started!\n");
#endif
    
    /* Set RF Interrupt flag to zero */
    rfData->int_RF = 0;
    
    /* Reonfigure the RF module*/
    RF_RFM95W_Config();
    
    /* Change RF Module to restart the receiving stage */
    RF_RFM95W_ChgStt();
    
    /* Clear RF flags */
    rfData->int_RF = 0;
    rfData->msgRcv = 0;
    rfData->msgSent = 0;
    
#if DEBUG_RF_RESET
    UART_PrintString("\nEnd of Reset Sequence!\n");
#endif    
}
#endif


/**
 * Function to clear the RF buffer
 */
void RF_ClrMsg(RFMSG_STRUCT *msg)
{
    memset(msg, 0x00, sizeof(RFMSG_STRUCT));
}


/**
 * Function to calculate the checksum of buffer of x bytes
 */
uint8_t RF_CksCalc(RFMSG_STRUCT *msg)
{
    uint8_t i;
    uint8_t *buffPt;
    uint16_t cks=0;

    buffPt = msg;

    for (i=0; i<msg->len-2; i++)
    {
        cks += *(buffPt+i);
    }
    cks += msg->ttl;

    cks = (uint8_t)(cks & 0x00FF);

    return cks;
}



/******************************************************************************/
/* System Functions                                                           */
/******************************************************************************/
uint8_t Memory_GetSavedData(SYS_STRUCT *sysData, RF_STRUCT *rfData)
{
	/* Read Configs saved in memory file */
	Memory_ReadPos(SRN_POS, &sysData->sn);

	if ((sys.sn < 1) || (sys.sn > 65534))
	{
		printf("\nSerial Number Out of Range!\n");
		return 1;
	}

	Memory_ReadPos(NET_POS, &sysData->net);

	Memory_ReadPos(ENC_POS, &sysData->encCtrl);

	if ((sysData->encCtrl < ENC_OFF) || (sysData->encCtrl > ENC_ON))
		sysData->encCtrl = ENC_OFF;

	Memory_ReadPos(RF_FREQ_POS, &rfData->freq);

	if ((rfData->freq < RF_868MHZ) || (rfData->freq > RF_918MHZ))
		rfData->freq = RF_868MHZ;
		
		
	Memory_ReadPos(TTLMAX_POS, &sysData->ttlMAX);

	if ((sysData->ttlMAX < 1) || (sysData->ttlMAX > TTL_DEFAULT))
		sysData->ttlMAX = TTL_DEFAULT;

	return 0;
}


/* Encryption functions */

/* The session_key should have been calculated before
 * Returns the new length of the message
 */
uint8_t AES128_Encrypt(uint8_t *buff, uint8_t buffLen, uint8_t *buffEnc, void *sessionKey)
{
    /* Copy to auxiliary buffer and add the length of the original message */
    auxLen = buffLen + 1;
    auxBuff[0] = buffLen;
    memcpy(auxBuff+1, buff, auxLen);

    /* The encryption is done in a 16bit block size*/
    if ((auxLen <= BLOCK_SIZE_1) && (auxLen > 0))
    {
        /* block with less than 16 bytes */

        /* Set the rest of the bytes to 0 */
        if (auxLen < BLOCK_SIZE_1)
            memset(auxBuff+auxLen, 0, BLOCK_SIZE_1-auxLen);

        AESECBEncryptBlock(auxBuff, sessionKey, buffEnc, AES_KEY_TYPE_128_BIT);

        return BLOCK_SIZE_1;
    }
    else if ((auxLen > BLOCK_SIZE_1) && (auxLen <= BLOCK_SIZE_2))
    {
        /* block with more than 16 bytes */

        /* Encrypt the first block already in auxBuff */
        AESECBEncryptBlock(auxBuff, sessionKey, buffEnc, AES_KEY_TYPE_128_BIT);

        /* Set the rest of the bytes to 0 */
        if (auxLen < BLOCK_SIZE_2)
        	memset(auxBuff+auxLen, 0, BLOCK_SIZE_2-auxLen);

        /* Encrypt the second block */
        AESECBEncryptBlock(auxBuff+BLOCK_SIZE_1, sessionKey, buffEnc+BLOCK_SIZE_1, AES_KEY_TYPE_128_BIT);

        return BLOCK_SIZE_2;
    }
    else if ((auxLen > BLOCK_SIZE_2) && (auxLen <= BLOCK_SIZE_3))
    {
        /* block with more than 16 bytes */

        /* Encrypt the first block already in auxBuff */
        AESECBEncryptBlock(auxBuff, sessionKey, buffEnc, AES_KEY_TYPE_128_BIT);

        /* Encrypt the second block already in auxBuff */
        AESECBEncryptBlock(auxBuff+BLOCK_SIZE_1, sessionKey, buffEnc+BLOCK_SIZE_1, AES_KEY_TYPE_128_BIT);

        /* Set the rest of the bytes to 0 */
        if (auxLen < BLOCK_SIZE_3)
            memset(auxBuff+auxLen, 0, BLOCK_SIZE_3-auxLen);

        /* Encrypt the second block */
        AESECBEncryptBlock(auxBuff+BLOCK_SIZE_2, sessionKey, buffEnc+BLOCK_SIZE_2, AES_KEY_TYPE_128_BIT);

        return BLOCK_SIZE_3;
    }


    /* Return 0 if the message isn't valid */
    return 0;
}


/* The session_key should have been calculated before */
uint8_t AES128_Decrypt(uint8_t *buffEnc, uint8_t buffLen, uint8_t *buffDec, void *sessionKey)
{
    /* The encryption is done in a 16bit block size*/
    if (buffLen == BLOCK_SIZE_1)
    {
        /* block of 16 bytes */
        AESECBDecryptBlock(buffEnc, sessionKey, auxBuff, AES_KEY_TYPE_128_BIT);
    }
    else if (buffLen == BLOCK_SIZE_2)
    {
        /* block with 32 bytes */

        /* Decrypt the first block */
        AESECBDecryptBlock(buffEnc, sessionKey, auxBuff, AES_KEY_TYPE_128_BIT);

        /* Decrypt the second block */
        AESECBDecryptBlock(buffEnc+BLOCK_SIZE_1, sessionKey, auxBuff+BLOCK_SIZE_1, AES_KEY_TYPE_128_BIT);
    }
    else if (buffLen == BLOCK_SIZE_3)
    {
        /* block with 32 bytes */

        /* Decrypt the first block */
        AESECBDecryptBlock(buffEnc, sessionKey, auxBuff, AES_KEY_TYPE_128_BIT);

        /* Decrypt the second block */
        AESECBDecryptBlock(buffEnc+BLOCK_SIZE_1, sessionKey, auxBuff+BLOCK_SIZE_1, AES_KEY_TYPE_128_BIT);

        /* Decrypt the third block */
        AESECBDecryptBlock(buffEnc+BLOCK_SIZE_2, sessionKey, auxBuff+BLOCK_SIZE_2, AES_KEY_TYPE_128_BIT);
    }
    else
    {
    	/* Not a valid message */
        return 0;
    }

    /* Copy from auxiliary buffer */
    memcpy(buffDec, auxBuff+1, buffLen);

    /* Return the length of the message decrypted */
    return auxBuff[0];
}



void SYS_ClearBuff(uint8_t *buff, uint8_t len)
{
    memset(buff, 0, len);
}


void InitConnections(void)
{	
     #ifdef UDP
    
	  /*Create UDP socket*/
	  clientSocket = socket(PF_INET, SOCK_DGRAM, 0);
	  /*Configure settings in address struct*/
	  serverAddr.sin_family = AF_INET;
	  serverAddr.sin_port = htons(portNum);
	  serverAddr.sin_addr.s_addr = inet_addr(serverIP);
	  memset(serverAddr.sin_zero, '\0', sizeof serverAddr.sin_zero);

	  /*Initialize size variable to be used later on*/
	  addr_size = sizeof serverAddr;
	  
	#endif
	  
	#ifdef TCP
	
		crcBypass=1;

		/*Create TCP socket*/
		clientSocket = socket(AF_INET, SOCK_STREAM, 0);

		/*Configure settings in address struct*/
		serverAddr.sin_family = AF_INET;
		serverAddr.sin_port = htons(portNum);
		serverAddr.sin_addr.s_addr = inet_addr(serverIP);
		memset(serverAddr.sin_zero, '\0', sizeof serverAddr.sin_zero);

		/*Initialize size variable to be used later on*/
		addr_size = sizeof serverAddr;
		
		if (clientSocket >= 0)
		{			
			if(connection < 0) connection=connect(clientSocket, (struct sockaddr *)&serverAddr, addr_size);
		}
		
	#else

    uart0_filestream = open("/dev/ttyUSB0", O_RDWR | O_NOCTTY | O_NDELAY | O_NONBLOCK);
    tcgetattr(uart0_filestream, &options);
    options.c_cflag = B19200 | CS8 | CSTOPB | CLOCAL | CREAD; //Set baud rate, data bytes
    options.c_iflag = IGNPAR;
    options.c_oflag = 0;
    options.c_lflag = 0;
    tcflush(uart0_filestream, TCIOFLUSH);
    tcsetattr(uart0_filestream, TCSANOW, &options);

	serialFlush(uart0_filestream);
	
	#endif
	
    ClearRx();
    ClearTx();    
    
  
    /*Read modbus addresses from CSV*/
	//ModbusAddr_Read(modbusAddr,nDataModbus);     

    
}

//int CheckSocket(void)
//{	
	//int ChkSk;
	//int error_code;
	//int error_code_size = sizeof(error_code);
	//ChkSk=getsockopt(clientSocket, SOL_SOCKET, SO_ERROR, &error_code, &error_code_size);
	
	//return ChkSk;
//}


void ClearRx()
{
    unsigned int i;

    for (i=0;i<RX_BUFFER;i++) rx_buffer[i] = '\0';
    rxEnd = 0;
    rxIndex = 0;
}

void ClearTx()
{
    unsigned int i;

    for (i=0;i<TX_BUFFER;i++) tx_buffer[i] = '\0';
}

void PrintString(int filestream, char *str, unsigned char length)
{
    unsigned int i;

    for(i=0;i<length;i++)
    {
        serialPutchar(filestream, str[i]);
    }

    //serialPutchar(filestream, '\r');
}

void ConvertLittleToBigEndian(unsigned char firstIndex, unsigned char length)
{
    unsigned char temp[length];
    unsigned char i;
    
    for (i=0;i<length;i++) { temp[i] = rx_buffer[firstIndex + length - i - 1]; }
	for (i=0;i<length;i++) { rx_buffer[firstIndex + i] = temp[i]; }
}


void ConvertIntelToBigEndian(unsigned char firstIndex, unsigned char length)
{
	unsigned char temp[length];
    unsigned char i;
	
	for (i=0;i<2;i++) { temp[i] = rx_buffer[firstIndex + i + 2]; }
	for (i=2;i<length;i++) { temp[i] = rx_buffer[firstIndex + i -2]; }	
	for (i=0;i<length;i++) { rx_buffer[firstIndex + 3 - i] = temp[i]; }	
}

void ModbusAddr_Read(int *AddrData, int nData)
{   
	FILE *fstream = fopen("modbusaddr.csv","r");
	char buffer[1024] ;   
    char *record, *line;   
    int i=0;
     
       
    if(fstream == NULL)   {      
       printf("\n file opening failed ");      
       return -1 ;   
    }   
    while((line=fgets(buffer,sizeof(buffer),fstream))!=NULL)   
    { 
		record = strtok(line,";");  
		modbusAddr[i] = (int)strtol(record, NULL, 16); 
		i++;
		nDataModbus=i;
		
		
	}

}

void HandleProcess()
{	

    unsigned int i;
	unsigned tempInt;
	float    tempFloat;
	//PrintString(uart0_filestream, &modbusQuery[0], 8);
    //delay(100); // Time to ensure response
    
    #ifdef UDP
		ioctl(clientSocket,FIONREAD,&bytesAv); //data avaliable check
		
		if(bytesAv>0)
		{
			nBytes = recvfrom(clientSocket,rx_buffer,RX_BUFFER-2,0,NULL, NULL);
			rxIndex=nBytes;
			if (rxIndex >= RX_BUFFER-2) rxEnd=1;
			rx_buffer[nBytes]='\0';
		}
	#endif	
	
	#ifdef TCP
	
		ioctl(clientSocket,FIONREAD,&bytesAv); //data avaliable check
		if(bytesAv>0)
		{
			
			nBytes = recv(clientSocket,rx_buffer,RX_BUFFER-2,0);
			rxIndex=nBytes;
			if (rxIndex >= RX_BUFFER-2) rxEnd=1;
			rx_buffer[nBytes]='\0';
			resetConnection=0;
		}
					
	#endif
	
	#ifdef RS485

		while(serialDataAvail(uart0_filestream) && rxEnd == 0)
		{
			rx_buffer[rxIndex] = serialGetchar(uart0_filestream);
			rxIndex++;
			if (rxIndex == RX_BUFFER-2) rxEnd = 1; // Overflow      
		}
		   
	#endif

	if (rxEnd == 0 && rxIndex > 0)
    {

		crcRx = CRC16(&rx_buffer[0],rxIndex-2);
		
        //DEBUG RX    
		//printf("RX[%d] = ",rxIndex-1);
		//for (i=0;i<rxIndex;i++) printf("%x ",rx_buffer[i]);
		//printf("\r\n");
		//printf("CRC = %x\r\n",crcRx);

        if (((rx_buffer[rxIndex-1] == (unsigned char)(crcRx >> 8)) && (rx_buffer[rxIndex-2] == (unsigned char)(crcRx & 0x00FF))) || crcBypass )
        {
            #ifdef JANITZA
            
				ConvertLittleToBigEndian(3,4);
				ConvertLittleToBigEndian(7,4);
				ConvertLittleToBigEndian(11,4);
				ConvertLittleToBigEndian(27,4);
				ConvertLittleToBigEndian(31,4);
				ConvertLittleToBigEndian(35,4);
				ConvertLittleToBigEndian(43,4);
				ConvertLittleToBigEndian(47,4);
				ConvertLittleToBigEndian(51,4);
				ConvertLittleToBigEndian(139,4);
	
				//Conversion to float
				memcpy(&v1,&rx_buffer[3],4);
				memcpy(&v2,&rx_buffer[7],4);
				memcpy(&v3,&rx_buffer[11],4);
				memcpy(&i1,&rx_buffer[27],4);
				memcpy(&i2,&rx_buffer[31],4);
				memcpy(&i3,&rx_buffer[35],4);
				memcpy(&p1,&rx_buffer[43],4);
				memcpy(&p2,&rx_buffer[47],4);
				memcpy(&p3,&rx_buffer[51],4);
				memcpy(&kwhSum,&rx_buffer[139],4);
				kwhSum = kwhSum / 1000.0;			
				            
            #endif
			
			#ifdef 3R
			
				ConvertLittleToBigEndian(3,2);
				ConvertLittleToBigEndian(5,2);
				ConvertLittleToBigEndian(7,2);
				ConvertLittleToBigEndian(9,2);
				ConvertLittleToBigEndian(11,2);
				ConvertLittleToBigEndian(13,2);
				ConvertLittleToBigEndian(15,2);
				ConvertLittleToBigEndian(17,2);
				ConvertLittleToBigEndian(19,2);
				ConvertLittleToBigEndian(21,2);
				ConvertLittleToBigEndian(23,2);
				ConvertLittleToBigEndian(25,2);
				ConvertLittleToBigEndian(27,2);
	
				//Conversion to float
				//memcpy(&v1,&rx_buffer[3],4);
				//memcpy(&v2,&rx_buffer[7],4);
				//memcpy(&v3,&rx_buffer[11],4);
				//memcpy(&i1,&rx_buffer[27],4);
				//memcpy(&i2,&rx_buffer[31],4);
				//memcpy(&i3,&rx_buffer[35],4);
				//memcpy(&p1,&rx_buffer[43],4);
				//memcpy(&p2,&rx_buffer[47],4);
				//memcpy(&p3,&rx_buffer[51],4);
				//memcpy(&kwhSum,&rx_buffer[139],4);
				//kwhSum = kwhSum / 1000.0;				
			
			#endif			
            
            #ifdef CCK
				#ifdef RS485
					if (initMeasure == 0 && rx_buffer[2] == 16) //rx_buffer[2] -> data byte count
					{					
						ConvertIntelToBigEndian(3,4);
						ConvertIntelToBigEndian(7,4);
						ConvertIntelToBigEndian(11,4);
						ConvertIntelToBigEndian(15,4);
						
						memcpy(&secTP,&rx_buffer[3],4);
						memcpy(&primTP,&rx_buffer[7],4);
						memcpy(&secTC,&rx_buffer[11],4);
						memcpy(&primTC,&rx_buffer[15],4);
						
						initMeasure = 1;
						RTP = primTP / secTP;
						RTC = primTC / secTC;										
								
					}				
					else if (initMeasure > 0) 
					{            
						if (initMeasure == 1) { ResetProcessVars();	initMeasure = 2; }
				
						
						ConvertIntelToBigEndian(3,4);
						ConvertIntelToBigEndian(7,4);
						ConvertIntelToBigEndian(11,4);
						ConvertIntelToBigEndian(35,4);
						ConvertIntelToBigEndian(39,4);
						ConvertIntelToBigEndian(43,4);
						ConvertIntelToBigEndian(51,4);
						ConvertIntelToBigEndian(55,4);
						ConvertIntelToBigEndian(59,4);
						ConvertIntelToBigEndian(143,4);
						ConvertIntelToBigEndian(147,4);
		
						//Conversion to float
						
						memcpy(&v1,&rx_buffer[3],4);
						memcpy(&v2,&rx_buffer[7],4);
						memcpy(&v3,&rx_buffer[11],4);
						memcpy(&i1,&rx_buffer[35],4);
						memcpy(&i2,&rx_buffer[39],4);
						memcpy(&i3,&rx_buffer[43],4);
						memcpy(&p1,&rx_buffer[51],4);
						memcpy(&p2,&rx_buffer[55],4);
						memcpy(&p3,&rx_buffer[59],4);
						memcpy(&kwhSum,&rx_buffer[143],4);
						memcpy(&mwhSum,&rx_buffer[147],4);
						
						v1 = RTP * v1; v2 = RTP * v2; v3 = RTP * v3;
						i1 = RTC * i1; i2 = RTC * i2; i3 = RTC * i3;
						p1 = RTP * RTC * p1; p2 = RTP * RTC * p2; p3 = RTP * RTC * p3;
						kwhSum = RTP * RTC * (kwhSum  + mwhSum/1000000.0);	
					}				
					else initMeasure = 0;		
				#endif
				
				#ifdef TCP
            
					initMeasure = 2;
								
					if (initMeasure > 0) 
																		{            
						if (initMeasure == 1) { ResetProcessVars();	initMeasure = 2; }
							ConvertIntelToBigEndian(9,4);
							ConvertIntelToBigEndian(13,4);
							ConvertIntelToBigEndian(17,4);
							
							ConvertIntelToBigEndian(45,4);
							ConvertIntelToBigEndian(49,4);
							ConvertIntelToBigEndian(53,4);
							
							ConvertIntelToBigEndian(61,4);
							ConvertIntelToBigEndian(65,4);
							ConvertIntelToBigEndian(69,4);
							
							ConvertIntelToBigEndian(153,4);
							ConvertIntelToBigEndian(157,4);
							
							ConvertIntelToBigEndian(249,4);
							ConvertIntelToBigEndian(253,4);
							ConvertIntelToBigEndian(257,4);
							ConvertIntelToBigEndian(261,4);
			
							//Conversion to float
							memcpy(&v1,&rx_buffer[9],4);
							memcpy(&v2,&rx_buffer[13],4);
							memcpy(&v3,&rx_buffer[17],4);
							memcpy(&i1,&rx_buffer[45],4);
							memcpy(&i2,&rx_buffer[49],4);
							memcpy(&i3,&rx_buffer[53],4);
							memcpy(&p1,&rx_buffer[61],4);
							memcpy(&p2,&rx_buffer[65],4);
							memcpy(&p3,&rx_buffer[69],4);
							memcpy(&kwhSum,&rx_buffer[153],4);
							memcpy(&mwhSum,&rx_buffer[157],4);
							
							memcpy(&secTP,&rx_buffer[249],4); //241
							memcpy(&primTP,&rx_buffer[253],4); //245
							memcpy(&secTC,&rx_buffer[257],4); //249
							memcpy(&primTC,&rx_buffer[261],4); //253
							
							
							RTP = primTP / secTP;
							RTC = primTC / secTC;	
							
							v1 = RTP * v1; v2 = RTP * v2; v3 = RTP * v3;
							i1 = RTC * i1; i2 = RTC * i2; i3 = RTC * i3;
							p1 = RTP * RTC * p1; p2 = RTP * RTC * p2; p3 = RTP * RTC * p3;
							kwhSum = RTP * RTC * (kwhSum  + mwhSum/1000000.0);	
						
					}				
					else initMeasure = 0;		
																			
				#endif																							            
            #endif
            
            
            
            #ifdef EMBRASUL_MD30_ETH

				if (initMeasure == 0) initMeasure = 1;
		
				else if (initMeasure > 0) 
				{            
					if (initMeasure == 1) { ResetProcessVars();	initMeasure = 2; }
					
					ConvertIntelToBigEndian(9,4);
					ConvertIntelToBigEndian(13,4);
					ConvertIntelToBigEndian(17,4);
					ConvertIntelToBigEndian(21,4);
					ConvertIntelToBigEndian(25,4);
					ConvertIntelToBigEndian(29,4);
					ConvertIntelToBigEndian(33,4);
					ConvertIntelToBigEndian(37,4);
					ConvertIntelToBigEndian(41,4);
					ConvertIntelToBigEndian(81,4);
					ConvertIntelToBigEndian(85,4);
					ConvertIntelToBigEndian(89,4);
					ConvertIntelToBigEndian(149,4);					
	
					//Conversion to float
					memcpy(&v1,&rx_buffer[9],4);
					memcpy(&v2,&rx_buffer[13],4);
					memcpy(&v3,&rx_buffer[17],4);
					memcpy(&i1,&rx_buffer[21],4);
					memcpy(&i2,&rx_buffer[25],4);
					memcpy(&i3,&rx_buffer[29],4);
					memcpy(&p1,&rx_buffer[33],4);
					memcpy(&p2,&rx_buffer[37],4);
					memcpy(&p3,&rx_buffer[41],4);
					memcpy(&auxfp1,&rx_buffer[81],4);
					memcpy(&auxfp2,&rx_buffer[85],4);
					memcpy(&auxfp3,&rx_buffer[89],4);
					memcpy(&kwhSum,&rx_buffer[149],4);

					kwhSum = kwhSum/1000.0;	
				}				
				else initMeasure = 0;		
															            
            #endif
            
            
            #ifdef FRONIUS
				
				initMeasure = 2;
				
				if (initMeasure > 0) 
				{            
						if (initMeasure == 1) { ResetProcessVars();	initMeasure = 2; }						
						ConvertLittleToBigEndian(33,4);
						ConvertLittleToBigEndian(37,4);
						ConvertLittleToBigEndian(41,4);
						ConvertLittleToBigEndian(9,4);
						ConvertLittleToBigEndian(13,4);
						ConvertLittleToBigEndian(17,4);
						ConvertLittleToBigEndian(45,4);
						ConvertLittleToBigEndian(49,4);
						ConvertLittleToBigEndian(61,4);
						ConvertLittleToBigEndian(65,4);
						
						
		
						//Conversion to float
						
						
						memcpy(&v1,&rx_buffer[33],4); //v1
						memcpy(&v2,&rx_buffer[45],4); //Ptotal
						memcpy(&v3,&rx_buffer[49],4); //Hz
						
						memcpy(&i1,&rx_buffer[9],4);  //I1

						memcpy(&p3,&rx_buffer[61],4);//FP
						memcpy(&kwhSum,&rx_buffer[65],4);
						
						
						kwhSum = kwhSum/1000.0;
						
							
				}				
				else initMeasure = 0;		
															            
            #endif
            
            
            #ifdef REMOTE_POLL
            
				AverageMeasures();
				if (sample >= MAX_SAMPLE) ResetProcessVars();    
			
			#endif
			fp1=(short int)(auxfp1*10000.0);
			fp2=(short int)(auxfp2*10000.0);
			fp3=(short int)(auxfp3*10000.0);
           	//if (v1!=0.0 && i1!=0.0) fp2 = (int)((p1/(v1*i1))*10000.0); else fp1 = 0;
			//if (v2!=0.0 && i2!=0.0) fp2 = (int)((p2/(v2*i2))*10000.0); else fp2 = 0;
			//if (v3!=0.0 && i3!=0.0) fp3 = (int)((p3/(v3*i3))*10000.0); else fp3 = 0;
            
         }
         
        //pwrPt->kwhSum = kwhSum;
         
        //Representation
     
		#if DEBUG_FLAG
         
			#ifdef CCK
				if (initMeasure > 0) printf("PrimTP = %4.2f SecTP = %4.2f PrimTC = %4.2f SecTC = %4.2f RTP = %4.2f RTC = %4.2f\r\n",primTP,secTP,primTC,secTC,RTP,RTC);
			#endif
									
			#ifndef FRONIUS
			printf("#%5.1f\r\n",sample);
			printf("V1(V) = %6.2f  I1(A) = %6.2f  P1(W) = %6.2f  FP1 = %6.4f\r\n",v1,i1,p1,(float)fp1/10000.0);
			printf("V2(V) = %6.2f  I2(A) = %6.2f  P2(W) = %6.2f  FP2 = %6.4f\r\n",v2,i2,p2,(float)fp2/10000.0);
			printf("V3(V) = %6.2f  I3(A) = %6.2f  P3(W) = %6.2f  FP3 = %6.4f\r\n",v3,i3,p3,(float)fp3/10000.0);
			printf("Consumption(kWh) = %10.2f\r\n\n",kwhSum);
			#endif
			
			#ifdef FRONIUS
			printf("#%5.1f\r\n",sample);
			printf("V1(V) = %6.2f  I1(A) = %6.2f  Pt(W) = %6.2f  \r\n",v1,i1,v2);
			printf(" f(Hz) = %6.2f  FP = %d\r\n",v3,fp1);
			printf("Consumption(kWh) = %10.2f\r\n\n",kwhSum);
			#endif
			
        #endif
    }

    ClearRx();
    ClearTx();
    
   if(resetConnection>=5) 
	{
		//printf("reconecting...");
		if (clientSocket >= 0) 
		{
			close(clientSocket); //Free resource
			delay(5000); //Wait 5 sec
		}

		connection=-1;
		connectionRetry++;

		//printf("Retry %d\r\n", connectionRetry);		
		if (connectionRetry > 50) system("sudo shutdown -r now");

		InitConnections();
		resetConnection=0;		
	}
   
    #ifdef RS485
		serialFlush(uart0_filestream);
		
		#ifdef CCK
			if (initMeasure == 0) PrintString(uart0_filestream, &modbusGetRT[0], 8);
			else PrintString(uart0_filestream, &modbusQuery[0], 8); //Moved from beggining to end to avoid delay(100), because this cycle runs each 500 ms.
		#endif
	
		#ifdef JANITZA
			PrintString(uart0_filestream, &modbusQuery[0], 8); 
		#endif	

		#ifdef 3R		
			PrintString(uart0_filestream, &modbusQuery[0], 8);
		#endif			
		
    #endif
    
	
	#ifdef UDP
		if (initMeasure == 0) sendto(clientSocket,modbusGetRT,sizeof(modbusGetRT),0,(struct sockaddr *)&serverAddr,addr_size);	
		else sendto(clientSocket,modbusQuery,sizeof(modbusQuery),0,(struct sockaddr *)&serverAddr,addr_size); //Moved from beggining to end to avoid delay(100), because this cycle runs each 500 ms.		
	#endif	
	
	#ifdef TCP
		if (connection >= 0) send(clientSocket,modbusQuery,sizeof(modbusQuery),0); //Moved from beggining to end to avoid delay(100), because this cycle runs each 500 ms.		
		resetConnection++;	

	#endif			
    
    //socket->write("Test in progress\r\n", 18);
        
}

unsigned int CRC16(unsigned char *nData, unsigned int wLength)
{
static const unsigned int wCRCTable[] = {
0X0000, 0XC0C1, 0XC181, 0X0140, 0XC301, 0X03C0, 0X0280, 0XC241,
0XC601, 0X06C0, 0X0780, 0XC741, 0X0500, 0XC5C1, 0XC481, 0X0440,
0XCC01, 0X0CC0, 0X0D80, 0XCD41, 0X0F00, 0XCFC1, 0XCE81, 0X0E40,
0X0A00, 0XCAC1, 0XCB81, 0X0B40, 0XC901, 0X09C0, 0X0880, 0XC841,
0XD801, 0X18C0, 0X1980, 0XD941, 0X1B00, 0XDBC1, 0XDA81, 0X1A40,
0X1E00, 0XDEC1, 0XDF81, 0X1F40, 0XDD01, 0X1DC0, 0X1C80, 0XDC41,
0X1400, 0XD4C1, 0XD581, 0X1540, 0XD701, 0X17C0, 0X1680, 0XD641,
0XD201, 0X12C0, 0X1380, 0XD341, 0X1100, 0XD1C1, 0XD081, 0X1040,
0XF001, 0X30C0, 0X3180, 0XF141, 0X3300, 0XF3C1, 0XF281, 0X3240,
0X3600, 0XF6C1, 0XF781, 0X3740, 0XF501, 0X35C0, 0X3480, 0XF441,
0X3C00, 0XFCC1, 0XFD81, 0X3D40, 0XFF01, 0X3FC0, 0X3E80, 0XFE41,
0XFA01, 0X3AC0, 0X3B80, 0XFB41, 0X3900, 0XF9C1, 0XF881, 0X3840,
0X2800, 0XE8C1, 0XE981, 0X2940, 0XEB01, 0X2BC0, 0X2A80, 0XEA41,
0XEE01, 0X2EC0, 0X2F80, 0XEF41, 0X2D00, 0XEDC1, 0XEC81, 0X2C40,
0XE401, 0X24C0, 0X2580, 0XE541, 0X2700, 0XE7C1, 0XE681, 0X2640,
0X2200, 0XE2C1, 0XE381, 0X2340, 0XE101, 0X21C0, 0X2080, 0XE041,
0XA001, 0X60C0, 0X6180, 0XA141, 0X6300, 0XA3C1, 0XA281, 0X6240,
0X6600, 0XA6C1, 0XA781, 0X6740, 0XA501, 0X65C0, 0X6480, 0XA441,
0X6C00, 0XACC1, 0XAD81, 0X6D40, 0XAF01, 0X6FC0, 0X6E80, 0XAE41,
0XAA01, 0X6AC0, 0X6B80, 0XAB41, 0X6900, 0XA9C1, 0XA881, 0X6840,
0X7800, 0XB8C1, 0XB981, 0X7940, 0XBB01, 0X7BC0, 0X7A80, 0XBA41,
0XBE01, 0X7EC0, 0X7F80, 0XBF41, 0X7D00, 0XBDC1, 0XBC81, 0X7C40,
0XB401, 0X74C0, 0X7580, 0XB541, 0X7700, 0XB7C1, 0XB681, 0X7640,
0X7200, 0XB2C1, 0XB381, 0X7340, 0XB101, 0X71C0, 0X7080, 0XB041,
0X5000, 0X90C1, 0X9181, 0X5140, 0X9301, 0X53C0, 0X5280, 0X9241,
0X9601, 0X56C0, 0X5780, 0X9741, 0X5500, 0X95C1, 0X9481, 0X5440,
0X9C01, 0X5CC0, 0X5D80, 0X9D41, 0X5F00, 0X9FC1, 0X9E81, 0X5E40,
0X5A00, 0X9AC1, 0X9B81, 0X5B40, 0X9901, 0X59C0, 0X5880, 0X9841,
0X8801, 0X48C0, 0X4980, 0X8941, 0X4B00, 0X8BC1, 0X8A81, 0X4A40,
0X4E00, 0X8EC1, 0X8F81, 0X4F40, 0X8D01, 0X4DC0, 0X4C80, 0X8C41,
0X4400, 0X84C1, 0X8581, 0X4540, 0X8701, 0X47C0, 0X4680, 0X8641,
0X8201, 0X42C0, 0X4380, 0X8341, 0X4100, 0X81C1, 0X8081, 0X4040 };

unsigned char nTemp;
unsigned int wCRCWord = 0xFFFF;

   while (wLength--)
   {
      nTemp = *nData++ ^ wCRCWord;
      wCRCWord >>= 8;
      wCRCWord ^= wCRCTable[nTemp];
   }
   return wCRCWord;
}

void ResetProcessVars(void)
{
	v1Sum = 0.0; v2Sum = 0.0; v3Sum = 0.0;
    i1Sum = 0.0; i2Sum = 0.0; i3Sum = 0.0;
    p1Sum = 0.0; p2Sum = 0.0; p3Sum = 0.0;
    sample = 0.0;
}

void AverageMeasures(void)
{
	sample = sample + 1; //Must be before calculations to avoid division per 0
	v1Sum = v1Sum + v1;
	v1 = v1Sum / sample;
	v2Sum = v2Sum + v2;
	v2 = v2Sum / sample;
	v3Sum = v3Sum + v3;
	v3 = v3Sum / sample;
	i1Sum = i1Sum + i1;
	i1 = i1Sum / sample;
	i2Sum = i2Sum + i2;
	i2 = i2Sum / sample;
	i3Sum = i3Sum + i3;
	i3 = i3Sum / sample;
	p1Sum = p1Sum + p1;
	p1 = p1Sum / sample;
	p2Sum = p2Sum + p2;
	p2 = p2Sum / sample;
	p3Sum = p3Sum + p3;
	p3 = p3Sum / sample;
}
	
	
	



